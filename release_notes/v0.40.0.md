# v0.4.0 Release Notes

## Bug Fixes

### `batch()` — nested batch namespace collision fixed

Previously all `batch()` steps wrote the current item to the hardcoded `shared.__batchItem` key. Nesting two `batch()` calls would cause the inner batch to overwrite the outer batch's item, making the outer item inaccessible inside the inner processor.

**Before:**

```ts
// outer's __batchItem was lost inside the inner batch
flow.batch(
  (s) => s.users,
  (b) =>
    b.batch(
      (s) => s.__batchItem.posts,
      (inner) =>
        inner.startWith((s) => {
          // s.__batchItem is now a Post — the User is gone
        }),
    ),
);
```

**After:** pass a `{ key }` option to give each batch level its own property name.

```ts
flow.batch(
  (s) => s.users,
  (b) =>
    b
      .startWith((s) => {
        /* s.__user is the current User */
      })
      .batch(
        (s) => s.__user!.posts,
        (inner) =>
          inner.startWith((s) => {
            // both s.__user (User) and s.__post (Post) are accessible
            console.log(s.__user, s.__post);
          }),
        { key: "__post" },
      ),
  { key: "__user" },
);
```

The `key` option defaults to `"__batchItem"` so existing code is fully backward-compatible.

### Improved restore behaviour

The save/restore logic for the batch item key was changed to use `Object.prototype.hasOwnProperty` instead of an `=== undefined` check. This means a property explicitly set to `undefined` on `shared` before the batch runs is now correctly preserved after the batch completes.
